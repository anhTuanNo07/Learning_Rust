fn main() {
    let mut x: i32 = 10;
    println!("x = {}", x);

    x = 20;
    println!("x =  {}", x);

    const HANG_SO: u128 = 1000_000_000_000;
    println!("HANG_SO = {}", HANG_SO)
}

fn main() {
    // Shadowing
    let x: i32 = 10;
    println!("x = {}", x);
    let x: &str = "ten";
    println!("x = {}", x);
}

fn main() {
    let a: i32 = 111_111; // Decimals
    let b: i32 = 0xff; // Hex
    let c: i32 = 0o77; //Octal
    let d: i32 = 0b1111_0000; // Binary
    let e: u8 = b'A'; // Byte
    println!("a = {}", a);
    println!("b = {}", b);
    println!("c = {}", c);
    println!("c = {}", d);
    println!("e = {}", e);

}

fn main() {
    let f: f64 = 2.0;
    let g: f32 = 3.0;

    let sum: i32 = 3 + 4;
    let subtraction: i32 = 5 - 4;
    let multiplication: i32 = 3 * 5;
    let division: f64 = 40.4 / 20.4;
    let remainder: i32 = 43 % 4;
    println!("sum = {}", sum);
    println!("subtraction = {}", subtraction);
    println!("multiplication = {}", multiplication);
    println!("division = {}", division);
    println!("remainder = {}", remainder);
}

fn main() {
    let tup: (&str, i32) = ("hello", 10000);
    println!("{:?}", tup);
    // let (_string: &str, _integer: i32) =  tup;
    let _integer: i32 = tup.1;
    println!("{}",  _integer);
}

fn main() {
    let number = [100, 200, 300];
    let get_number = number[1];

    println!("number = {}", get_number);
}

// Owner

// Error
fn main() {
    let _s1 = String::from("Hello");
    let _s2 = _s1;
    println!("{}", _s1);
}

// fix 
fn main() {
    let _s1 = String::from("Hello world!");
    let _s2 = _s1.clone();
    println!("{}", _s1);
}

// Similarity
fn main() {
    let s = String::from("Hello world!");
    take_ownership(s);
    println!("{}", s);
}

fn take_ownership(_string: String) {
    println!("{}", _string);
}

// solution 
fn main() {
    let s1 = give_ownership();
    let s2 = String::from("Hello World!");
    let s3 = takes_and_gives_back(s2);
    println!("{}, {}", s1, s3);
}

fn give_ownership() -> String {
    let some_string = String::from("Hello World!");
    some_string
}

fn takes_and_gives_back(some_string: String) -> String {
    some_string
}


// Assign and return value to function
fn main() {
    let s1 = String::from("Hello");
    let (s2, len) = calculate_length(s1);
    println!("Do dai cua {} la {}", s2, len);
}

fn calculate_length(some_string: String) -> (String, usize) {
    let length = some_string.len();
    (some_string, length)
}

// Using reference
fn main() {
    let mut s1 = String::from("Hello");
    let len = calculate_length(&mut s1);
    println!("Do dai cua {} la {}", s1, len);
}

fn calculate_length(some_string: &mut String) -> usize {
    some_string.push_str(" world!");
    let length = some_string.len();
    length
}

// Struct
#[derive(Debug)]
struct Member {
    username: String,
    email: String,
    age: u64,
    active: bool,
}

fn main() {
    let mut member1 = Member {
        email: String::from("anhtuan@gmail.com"),
        username: String::from("anhtuan"),
        age: 28,
        active: true,
    };

    let member2 = create_new_member(
        String::from("DaoAnhTuan"), 
        String::from("anhtuanpcipho2@gmail.com"), 
        30
    );

    let member3  = Member{
        username: String::from("John"),
        ..member2
    };

    println!("member3 = {:#?}", member3);
}

fn create_new_member (username: String, email: String, age: u64) -> Member {
    Member {
        email: email,
        username: username,
        age: age,
        active: true,
    }
}

// End Struct

// Dien tich hinh chu nhat
fn main() {
    let dai = 30;
    let rong = 50;

    println!("Dien tich hinh chu nhat la {}", dien_tich(dai, rong));
}

fn dien_tich(dai: u32, rong: u32) -> u32 {
    dai * rong
}
// Thay doi cach input
fn main() {
    let hinh_chu_nhat = (30, 50);

    println!("Dien tich hinh chu nhat la {}", dien_tich(hinh_chu_nhat));
}

fn dien_tich(kich_thuoc: (u32, u32)) -> u32 {
    kich_thuoc.0 * kich_thuoc.1
}

// Dung struct de tinh dien tichstruct hinhChuNhat {
    dai: u32, 
    rong: u32,
}

fn main() {
    let kichThuoc = hinhChuNhat {
        dai: 50,
        rong: 30,
    };

    println!("dien tich hinh chu nhat la {}", dien_tich(&kichThuoc))
}

fn dien_tich(kich_thuoc: &hinhChuNhat) -> u32 {
    kich_thuoc.dai * kich_thuoc.rong
}

// implement struct 
struct hinhChuNhat {
    dai: u32, 
    rong: u32,
}

impl hinhChuNhat {
    fn dien_tich(&self) -> u32 {
        self.dai * self.rong
    }

    fn chua(&self, hinhChuNhatKhac: &hinhChuNhat) -> bool {
        self.dai > hinhChuNhatKhac.dai && self.rong > hinhChuNhatKhac.rong
    }
}
fn main() {
    let kichThuoc = hinhChuNhat {
        dai: 50,
        rong: 30,
    };

    let kichThuoc2 = hinhChuNhat {
        dai: 40,
        rong: 20,
    };

    println!("dien tich hinh chu nhat la {}", kichThuoc.dien_tich());

    println!("hinh chu nhat co the chua hinh 2: {}", kichThuoc.chua(&kichThuoc2))
}

// --- Bai hoc so 4: Cach su dung Enum, Option Enum & Match ---

// sample code
#[derive(Debug)]

enum IpAddressKind {
    V4(u8, u8, u8, u8), 
    V6(String),
}

#[derive(Debug)]
struct _IpAddress {
    kind: IpAddressKind
    ,address: String,
}
fn main() {
    let localhost = IpAddressKind::V4(127, 0, 0, 1);

    println!("localhost = {:#?}", localhost)
}

fn route(ip_kind: IpAddressKind) {}

// Option Enum
fn main() {
    let x = 5;
    let y = Some(5);
    let z: Option<i32> = None;

    let sum  = x + y.unwrap_or(0);
    let sum2 = x + z.unwrap_or(1);
    println!("sum = {}", sum);
    println!("sum2 = {}", sum2);

}

// Match Option
// sample code 
fn main() {
    decimals(Coin::Bitcoin(Balance::Shark));
}

#[derive(Debug)]
enum Balance {
    Small, 
    Intermediate,
    Fish, 
    Shark,
}
enum Coin {
    Solana,
    Ethereum,
    Near,
    Bitcoin(Balance),
}

fn decimals(coin: Coin) -> u8 {
    match coin {
        Coin::Solana => {
            println!("Solana Match");
            1
        },
        Coin::Ethereum => 10,
        Coin::Near => 20,
        Coin::Bitcoin(bala) => {
            println!("I am a {:#?}", bala);
            30
        },
    }
}

// sample code 2
fn main() {
    let five = Some(5);
    let six = plus_one(five);

    println!("six = {:#?}", six);

    let none = plus_one(None);
    println!("none = {:#?}", none)
}

fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(x) => Some(x + 1),
        _ => None,
    }
}

// if let some 
fn main() {
    let _value = Some(4);
    match _value {
        Some(5) => println!("bang 5"),
        _ => println!("khac 5"),
    }
}

// --- Bai hoc so 5: Quan ly du an va cach su dung Packages, Crates, Modules ---

cargo new --bin name: Tao package folder ten name

web crates.io: tong hop cac crates

So luoc trong file Cargo.toml:
- [package]: bao gom cac thong so nhu:
+ name: Ten package
+ version: phien ban. VD "0.1.0"
+ edition: nam phat hanh VD "2021"

- [dependencies]: Luu tru cac dependencies: Chi can viet ten cac package kem voi version, se duoc tu dong cai cac dependencies can thiet

file Cargo.lock: luu tru cac thong tin co dinh cho package, VD: name, version, source (github), va checksum (ma hash)

cargo new --lib libfiles: Tao mot library, khong co file main, nhung lai co file lib.rs, dung de su dung cho nhieu truong hop khac.

// sample moduole
mod front_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
        pub fn seat_at_table() {}
    }

    pub mod serving {
        pub fn take_order() {}
        pub fn take_payment() {}
    }
}

fn call_order() {}

mod test{
    mod back_house {
        fn cook_order() {}
        fn fix_order() {
            super::super::call_order();
            cook_order();
        }
    }
}

fn eat_at_restaurent() {
    crate::front_house::hosting::add_to_waitlist();
}

// sample 2


use fmt::io;
use rand::Rng;
user rand::RngCore;
user rand::SeedableRng;
mod back_house {
    pub struct Breakfast {
        toast: String,
        fruit: String.
    }

    pub enum Salad {
        Soup, 
        Salad,
    }

    impl Breakfast {
        fn monday(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                fruilt: String::from("banana")
            }
        }
    }
}

mod front_house {
    pub mod hosting  {
        fn add_to_waiting() {}
    }
}

fn eat_an_reataurant() {
    let mut order = back_house::Breakfast::momday("Fish")
    order.toast = String::From("Chicken")

    let order = back_house::Breakfast {
        toast: String::from("Wheat"),
        fruit: String::From("Apple"),
    }

    let order2 = back_house::Salad::Salad
}

// --- Bai hoc so 6: Su dung Vector, String và HashMap ---
Day chinh la nhung kieu du lieu duoc luu trong vung nho Heap, noi co the phong to thu nho memory
// Vectors
fn main() {
    // Vectors
    let a = [1, 2, 3];
    let v  = vec![1, 2, 3];
    let mut v2 = Vec::new();
    v2.push(1);
    v2.push(2);
    v2.push(3);
    v2.push(4);
    println!("{:?}", v2)
}

// Match va Vector
fn main() {
    // Vectors
    let a = [1, 2, 3];
    let v  = vec![1, 2, 3, 4, 5, 6];
    let mut v2 = Vec::new();
    v2.push(1);
    v2.push(2);
    v2.push(3);
    v2.push(4);
    println!("{:?}", v2);

    let five = &v[5];
    match v.get(5) {
        Some(five) => println!("This is five element = {}", five),
        None => println!("This is not a four element")
    }
}

// Su dung enum voi Vector

fn main() {
    // Vectors
    enum SheetCell {
        Int(i32),
        Float(f64),
        Text(String)
    }

    let row =  vec![
        SheetCell::Int(5),
        SheetCell::Float(10.12),
        SheetCell::Text(String::from("Blue")),
    ];

    match &row[1] {
        &SheetCell::Float(i) => println!("{}", i),
        _ => println!("This is not a float"),
    }
}

// String
fn main() {
    // String 
    // UTF-8
    let s1 = String::from("A String");
    // empty string
    let s2 = String::new();
    // string of character
    let s3 = "A String";
    // convert &str to String
    let s4 = s3.to_string();
}
// sample code 2 for string
fn main() {
    // String 
    // UTF-8
    let s1 = String::from("A String");
    // empty string
    let s2 = String::from("Toi ten la Dao Anh Tuan");
    let s3 = String::from("ダオ　アン　ツア");
    // convert &str to String
    let s4 = String::from("***");

    let s5 = s2 + " in japanese is " + &s3;
    println!("{}", s5);

    println!("{}", s3);
}

// work with &str

use unicode_segmentation::UnicodeSegmentation;
fn main() {
    //String 
    // UTF-8
    let s3 = String::from("アン　ツアン");
    // Bytes
    for i in s3.bytes() {
        println!("{}", i)
    }

    // Scalar values
    for i in s3.chars() {
        println!("{}", i)
    }

    // Grapheme Clusters
    for i in s3.graphemes(true) {
        println!("{}", i)
    }

}

// HashMap
use std::collections::HashMap;
fn main() {
    // hashmap
    let mu = String::from("MU");
    let mc = String::from("MC");

    let mut scores = HashMap::new();

    scores.insert(mu, 10);
    scores.insert(mc, 9);

    let team_name = String::from("MU");
    let score = scores.get(&team_name);

    for (key, value) in &scores {
        println!("{} {}", key, value)
    }

    println!("score = {:?}", score)
}

// HashMap
use std::collections::HashMap;
fn main() {
    let text = "hello world this is wonderful world";

    let mut map = HashMap::new();
    for i in text.split_whitespace() {
        let count = map.entry(i).or_insert(0);
        *count += 1;
    }
    println!("{:?}", map)
}

// Qua trinh map tren kha giong voi mapping trong solidity 

// --- Bai hoc so 7: Generic ---
Tuong doi giong voi generic trong Typescript

// Bai hoc so 8: Traits in Rust ---
// Note: Tuogn doi giong voi Trait in PHP


// sample code
struct Data {
    num1: i32,
    num2: i32,
    str1: String,
    optional: Option<i32>,
}

struct Data2 {
    num1: i32,
    num2: i32,
    str1: String,
    optional: Option<i32>,
}

impl Data {
    fn new() -> Self{
        Data {
            num1: 15,
            num2: 25, 
            str1: "some string 2".to_string(),
            optional: None,
        }
    }
}

trait Transform {
    fn revert(&self) -> String {
        String::from("No string...")
    }
}

impl Transform for Data {
    fn revert(&self) -> String {
        self.str1.chars().rev().collect::<String>()
    }
}

impl Transform for Data2 {
    fn revert(&self) -> String {
        (self.num1 + self.num2).to_string()
    }
}

fn main() {
    let a = Data::new();

    let b = Data2 {
        num1: 10,
        num2: 20,
        str1: String::from("ok string"),
        optional: None,
    };
    
    println!("{}", a.revert());
}

// --- Bai hoc so 9: Life Time ---
Xem video de ro hon chi thiet

// --- Bai hoc so 10: Error handle & Result ---

